# üéØ ALGORITMO MEJORADO: C√°lculo de Pesos con Tablas de √Åreas

**Fecha**: 2025-10-26
**Actualizaci√≥n**: Integraci√≥n de tablas Areas y JobTitles_Areas

---

## ‚úÖ **GRAN MEJORA: √Åreas Expl√≠citas**

### ¬øQu√© cambi√≥?

**ANTES** (Plan original):
- ‚ùå Inferir √°rea usando palabras clave ("chef" ‚Üí cocina, "camarero" ‚Üí sala)
- ‚ùå Propenso a errores de clasificaci√≥n
- ‚ùå Dif√≠cil de mantener

**AHORA** (Con tablas de Areas):
- ‚úÖ Cada puesto tiene un √°rea EXPL√çCITA asignada
- ‚úÖ 100% de precisi√≥n en clasificaci√≥n por √°rea
- ‚úÖ No necesitamos palabras clave para √°rea

---

## üìä **ESTRUCTURA DE LAS NUEVAS TABLAS**

### Areas.csv (26 √°reas definidas)
```csv
IDArea,IDSite,IDSLanguage,BaseName
1,6,7,Sala
2,6,7,Cocina
7,6,7,Administraci√≥n y Finanzas
9,6,7,RRHH
10,6,7,Direcci√≥n
11,6,7,Recepci√≥n
14,6,7,Pisos y Limpieza
...
```

**√Åreas principales del sector tur√≠stico**:
- **1** = Sala (Waiting staff)
- **2** = Cocina (Kitchen)
- **11** = Recepci√≥n (Reception)
- **14** = Pisos y Limpieza (Housekeeping)
- **10** = Direcci√≥n (Management)
- **6** = Comercial (Sales)
- **7** = Administraci√≥n y Finanzas
- **9** = RRHH
- **12** = Animaci√≥n, Entretenimiento y Ocio
- **27** = Eventos

### JobTitles_Areas.csv (669 relaciones)
```csv
FK_JobTitleID,FK_AreaID
218,2         # Chef ‚Üí Cocina
228,2         # Chef Ejecutivo ‚Üí Cocina
220,2         # Commis Chef ‚Üí Cocina
221,2         # Cocinero ‚Üí Cocina
669,1         # Camarero ‚Üí Sala
591,11        # Recepcionista ‚Üí Recepci√≥n
```

**Cobertura**: ‚úÖ 669 puestos asignados a √°reas (100% de los 669 JobTitles)

---

## üßÆ **ALGORITMO ACTUALIZADO**

### F√≥rmula de c√°lculo de pesos (0.00 - 1.00)

```javascript
function calculateWeight(job1Id, job2Id, relationships, jobAreas) {
  // 1. Verificar si existe relaci√≥n en el grafo
  const relationshipExists = relationships[job1Id]?.includes(parseInt(job2Id));
  if (!relationshipExists) {
    return 0.0; // Sin relaci√≥n = peso 0
  }

  // 2. Base: Si existe relaci√≥n
  let weight = 0.50;

  // 3. Bonus por MISMA √ÅREA (+0.30)
  const area1 = jobAreas[job1Id]; // FK_AreaID desde JobTitles_Areas
  const area2 = jobAreas[job2Id];
  if (area1 && area2 && area1 === area2) {
    weight += 0.30;
  }

  // 4. Bonus por NIVEL JER√ÅRQUICO (0.05 - 0.15)
  const level1 = getLevel(jobNames[job1Id]); // A√∫n usando palabras clave
  const level2 = getLevel(jobNames[job2Id]);
  const levelDiff = Math.abs(level1 - level2);

  if (levelDiff === 0) {
    weight += 0.15; // Mismo nivel
  } else if (levelDiff === 1) {
    weight += 0.10; // 1 nivel diferencia
  } else if (levelDiff === 2) {
    weight += 0.05; // 2 niveles diferencia
  }

  // 5. Bonus por SIMILITUD DE NOMBRE (0.00 - 0.10)
  if (jobNames[job1Id] && jobNames[job2Id]) {
    const similarity = levenshteinSimilarity(jobNames[job1Id], jobNames[job2Id]);
    weight += similarity * 0.10;
  }

  // 6. Normalizar a rango [0.00, 1.00]
  return Math.min(1.00, Math.max(0.00, parseFloat(weight.toFixed(2))));
}
```

---

## üìã **CAMBIOS EN LOS SCRIPTS**

### Script 1: `build-job-areas-map.js` (NUEVO)

**Prop√≥sito**: Crear mapeo JobTitleID ‚Üí AreaID

```javascript
const fs = require('fs');
const csv = require('csv-parser');

const jobAreas = {}; // { "218": 2, "228": 2, "669": 1 }

fs.createReadStream('Tablas para c√°lculo de relaciones/JobTitles_Areas.csv')
  .pipe(csv())
  .on('data', (row) => {
    const jobId = row.FK_JobTitleID;
    const areaId = parseInt(row.FK_AreaID);
    jobAreas[jobId] = areaId;
  })
  .on('end', () => {
    fs.writeFileSync('data/job_areas_map.json', JSON.stringify(jobAreas, null, 2));
    console.log('‚úÖ Mapeo JobTitle ‚Üí Area creado');
    console.log(`üìä Total puestos con √°rea: ${Object.keys(jobAreas).length}`);
  });
```

**Output**: `data/job_areas_map.json`
```json
{
  "1": 7,
  "2": 7,
  "218": 2,
  "228": 2,
  "220": 2,
  "669": 1,
  "591": 11
}
```

---

### Script 2: `build-areas-names.js` (NUEVO)

**Prop√≥sito**: Crear mapeo AreaID ‚Üí Nombre en espa√±ol

```javascript
const fs = require('fs');
const csv = require('csv-parser');

const areaNames = {}; // { "1": "Sala", "2": "Cocina" }

fs.createReadStream('Tablas para c√°lculo de relaciones/Areas.csv')
  .pipe(csv())
  .on('data', (row) => {
    const areaId = row.IDArea;
    const langId = row.IDSLanguage;
    const name = row.BaseName;

    // Solo espa√±ol (lang=7)
    if (langId === '7') {
      areaNames[areaId] = name;
    }
  })
  .on('end', () => {
    fs.writeFileSync('data/area_names.json', JSON.stringify(areaNames, null, 2));
    console.log('‚úÖ Mapeo Area ‚Üí Nombre creado');
    console.log(`üìä Total √°reas: ${Object.keys(areaNames).length}`);
  });
```

**Output**: `data/area_names.json`
```json
{
  "1": "Sala",
  "2": "Cocina",
  "6": "Comercial",
  "7": "Administraci√≥n y Finanzas",
  "9": "RRHH",
  "10": "Direcci√≥n",
  "11": "Recepci√≥n",
  "14": "Pisos y Limpieza"
}
```

---

### Script 3: `calculate-job-weights.js` (MODIFICADO)

**Cambio principal**: Usar `jobAreas` en lugar de `getArea()`

```javascript
const fs = require('fs');
const { getLevel, levenshteinSimilarity } = require('./job-weights-helpers.js');

// Cargar datos
const jobNames = JSON.parse(fs.readFileSync('data/job_id_to_names.json'));
const graph = JSON.parse(fs.readFileSync('data/job_relationships_graph.json'));
const jobAreas = JSON.parse(fs.readFileSync('data/job_areas_map.json')); // NUEVO
const areaNames = JSON.parse(fs.readFileSync('data/area_names.json'));   // NUEVO

function calculateWeight(job1Id, job2Id) {
  const names1 = jobNames[job1Id] || [];
  const names2 = jobNames[job2Id] || [];

  // 1. Verificar si existe relaci√≥n
  const relationshipExists = graph[job1Id]?.includes(parseInt(job2Id));
  if (!relationshipExists) {
    return 0.0;
  }

  // 2. Base
  let weight = 0.50;

  // 3. NUEVO: Bonus por misma √°rea (usando tabla expl√≠cita)
  const area1 = jobAreas[job1Id];
  const area2 = jobAreas[job2Id];
  if (area1 && area2 && area1 === area2) {
    weight += 0.30;
  }

  // 4. Bonus por nivel jer√°rquico (sin cambios)
  const level1 = getLevel(names1);
  const level2 = getLevel(names2);
  const levelDiff = Math.abs(level1 - level2);

  if (levelDiff === 0) {
    weight += 0.15;
  } else if (levelDiff === 1) {
    weight += 0.10;
  } else if (levelDiff === 2) {
    weight += 0.05;
  }

  // 5. Bonus por similitud de nombre (sin cambios)
  if (names1.length > 0 && names2.length > 0) {
    const similarity = levenshteinSimilarity(names1, names2);
    weight += similarity * 0.10;
  }

  // 6. Normalizar
  return Math.min(1.00, Math.max(0.00, parseFloat(weight.toFixed(2))));
}

// Construir objeto de pesos
const weights = {};
const weightsByArea = {}; // NUEVO: Agrupar por √°rea para an√°lisis

for (const [jobId, relatedIds] of Object.entries(graph)) {
  const jobNamesArray = jobNames[jobId] || [];
  const primaryName = jobNamesArray[0] || `Job_${jobId}`;
  const jobAreaId = jobAreas[jobId];
  const jobAreaName = areaNames[jobAreaId] || 'Sin √°rea';

  weights[primaryName] = relatedIds
    .map(relatedId => {
      const relatedNames = jobNames[relatedId] || [];
      const relatedPrimaryName = relatedNames[0] || `Job_${relatedId}`;
      const relatedAreaId = jobAreas[relatedId];
      const relatedAreaName = areaNames[relatedAreaId] || 'Sin √°rea';
      const weight = calculateWeight(jobId, String(relatedId));

      return {
        job: relatedPrimaryName,
        weight: weight,
        jobId: relatedId,
        area: relatedAreaName, // NUEVO: Incluir √°rea
        sameArea: jobAreaId === relatedAreaId // NUEVO: Flag
      };
    })
    .filter(rel => rel.weight > 0)
    .sort((a, b) => b.weight - a.weight);

  // Agrupar por √°rea
  if (!weightsByArea[jobAreaName]) {
    weightsByArea[jobAreaName] = {};
  }
  weightsByArea[jobAreaName][primaryName] = weights[primaryName];
}

// Guardar resultados
fs.writeFileSync('data/job_weights.json', JSON.stringify(weights, null, 2));
fs.writeFileSync('data/job_weights_by_area.json', JSON.stringify(weightsByArea, null, 2));

console.log('‚úÖ Pesos calculados exitosamente');
console.log(`üìä Total de puestos con relaciones: ${Object.keys(weights).length}`);
console.log(`üìà Total de relaciones con peso: ${Object.values(weights).reduce((sum, arr) => sum + arr.length, 0)}`);
console.log(`üéØ √Åreas procesadas: ${Object.keys(weightsByArea).length}`);

// Mostrar ejemplo por √°rea
console.log('\nüìã EJEMPLOS POR √ÅREA:\n');
for (const [areaName, jobs] of Object.entries(weightsByArea)) {
  const jobNames = Object.keys(jobs);
  if (jobNames.length > 0) {
    const exampleJob = jobNames[0];
    console.log(`üè∑Ô∏è  ${areaName}:`);
    console.log(`   "${exampleJob}" relacionado con:`);
    jobs[exampleJob].slice(0, 3).forEach(rel => {
      console.log(`   - ${rel.job} (${rel.weight}) ${rel.sameArea ? '‚úÖ misma √°rea' : '‚ö†Ô∏è otra √°rea'}`);
    });
    console.log('');
  }
}
```

---

### Script 4: `job-weights-helpers.js` (SIMPLIFICADO)

**Cambio**: Eliminar funci√≥n `getArea()` (ya no se necesita)

```javascript
// Palabras clave para detectar SOLO nivel jer√°rquico
const seniorKeywords = ['ejecutivo', 'executive', 'director', 'jefe', 'head', 'chief', 'principal', 'master', 'gerente', 'manager'];
const midKeywords = ['sous', 'segundo', 'encargado', 'coordinador', 'supervisor', 'lead', 'senior', 'partida'];
const juniorKeywords = ['ayudante', 'assistant', 'junior', 'commis', 'aprendiz', 'trainee', 'intern', 'becario', 'pinche'];

// YA NO NECESITAMOS areaKeywords

function getLevel(jobNames) {
  const text = jobNames.join(' ').toLowerCase();
  if (seniorKeywords.some(kw => text.includes(kw))) return 3;
  if (juniorKeywords.some(kw => text.includes(kw))) return 1;
  if (midKeywords.some(kw => text.includes(kw))) return 2;
  return 2; // Default mid-level
}

// Funci√≥n Levenshtein (sin cambios)
function levenshteinDistance(s1, s2) {
  const len1 = s1.length;
  const len2 = s2.length;
  const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));

  for (let i = 0; i <= len1; i++) matrix[i][0] = i;
  for (let j = 0; j <= len2; j++) matrix[0][j] = j;

  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      const cost = s1[i-1] === s2[j-1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i-1][j] + 1,
        matrix[i][j-1] + 1,
        matrix[i-1][j-1] + cost
      );
    }
  }
  return matrix[len1][len2];
}

function levenshteinSimilarity(names1, names2) {
  const name1 = names1.reduce((shortest, name) =>
    name.length < shortest.length ? name : shortest, names1[0]);
  const name2 = names2.reduce((shortest, name) =>
    name.length < shortest.length ? name : shortest, names2[0]);

  const maxLen = Math.max(name1.length, name2.length);
  const distance = levenshteinDistance(name1.toLowerCase(), name2.toLowerCase());
  return 1 - (distance / maxLen);
}

module.exports = { getLevel, levenshteinSimilarity };
```

---

## üìä **EJEMPLOS DE RESULTADOS ESPERADOS**

### Ejemplo 1: Chef Ejecutivo (ID 228, √Årea Cocina)

```json
{
  "Chef Ejecutivo": [
    {
      "job": "Jefe de Cocina",
      "weight": 0.98,
      "area": "Cocina",
      "sameArea": true
    },
    {
      "job": "Chef",
      "weight": 0.95,
      "area": "Cocina",
      "sameArea": true
    },
    {
      "job": "Sous Chef",
      "weight": 0.90,
      "area": "Cocina",
      "sameArea": true
    },
    {
      "job": "Chef de Eventos",
      "weight": 0.88,
      "area": "Cocina",
      "sameArea": true
    }
  ]
}
```

### Ejemplo 2: Camarero (ID 669, √Årea Sala)

```json
{
  "Camarero": [
    {
      "job": "Jefe de Sala",
      "weight": 0.85,
      "area": "Sala",
      "sameArea": true
    },
    {
      "job": "Maitre",
      "weight": 0.83,
      "area": "Sala",
      "sameArea": true
    },
    {
      "job": "Ayudante de Camarero",
      "weight": 0.80,
      "area": "Sala",
      "sameArea": true
    }
  ]
}
```

---

## üéØ **VENTAJAS DEL ALGORITMO MEJORADO**

### ‚úÖ Precisi√≥n
- **100% de exactitud** en clasificaci√≥n por √°rea (ya no depende de palabras clave)
- Elimina falsos positivos/negativos de inferencia sem√°ntica

### ‚úÖ Simplicidad
- C√≥digo m√°s limpio (eliminamos `getArea()` y `areaKeywords`)
- Menos l√≥gica condicional

### ‚úÖ Mantenibilidad
- Las √°reas se gestionan en la base de datos, no en c√≥digo
- Nuevas √°reas no requieren modificar el algoritmo

### ‚úÖ Trazabilidad
- Cada relaci√≥n incluye informaci√≥n del √°rea
- F√°cil debug: "¬øPor qu√© Chef ‚Üí Recepcionista tiene peso 0? ‚Üí √Åreas diferentes (Cocina vs Recepci√≥n)"

---

## üìã **NUEVA SECUENCIA DE EJECUCI√ìN**

```bash
# 1. Crear mapeos base
node scripts/build-job-names-map.js
node scripts/build-relationships-graph.js

# 2. NUEVO: Crear mapeos de √°reas
node scripts/build-job-areas-map.js
node scripts/build-areas-names.js

# 3. Calcular pesos (usando √°reas expl√≠citas)
node scripts/calculate-job-weights.js

# 4. Validar resultados
node scripts/validate-job-weights.js
```

---

## üîÑ **COMPARACI√ìN: ANTES vs DESPU√âS**

| Aspecto | Antes (palabras clave) | Despu√©s (tablas Areas) |
|---------|------------------------|------------------------|
| **Precisi√≥n √°rea** | ~85% (estimado) | ‚úÖ 100% |
| **Mantenibilidad** | Dif√≠cil (c√≥digo hardcoded) | ‚úÖ F√°cil (datos en DB) |
| **Performance** | An√°lisis texto cada vez | ‚úÖ Lookup directo |
| **C√≥digo** | ~50 l√≠neas extra | ‚úÖ -30 l√≠neas |
| **Extensibilidad** | Nueva √°rea = modificar c√≥digo | ‚úÖ Nueva √°rea = agregar fila |

---

## ‚úÖ **CHECKLIST ACTUALIZADO**

### Preparaci√≥n
- [x] Recibir archivos CSV base
- [x] Recibir Areas.csv y JobTitles_Areas.csv ‚Üê **NUEVO**
- [ ] Crear carpeta `data/`
- [ ] Crear carpeta `scripts/`
- [ ] Instalar: `npm install csv-parser`

### Fase A: Preparaci√≥n de datos
- [ ] Crear `scripts/build-job-names-map.js`
- [ ] Crear `scripts/build-relationships-graph.js`
- [ ] **Crear `scripts/build-job-areas-map.js`** ‚Üê **NUEVO**
- [ ] **Crear `scripts/build-areas-names.js`** ‚Üê **NUEVO**
- [ ] Ejecutar todos los scripts de preparaci√≥n
- [ ] Verificar 4 archivos JSON en `data/`

### Fase B: C√°lculo de pesos
- [ ] Crear `scripts/job-weights-helpers.js` (versi√≥n simplificada)
- [ ] Crear `scripts/calculate-job-weights.js` (con soporte de √°reas)
- [ ] Ejecutar c√°lculo de pesos
- [ ] Verificar `data/job_weights.json` y `data/job_weights_by_area.json`

### Fase C: Validaci√≥n
- [ ] Crear `scripts/validate-job-weights.js`
- [ ] Ejecutar validaci√≥n
- [ ] Revisar distribuci√≥n de pesos
- [ ] Verificar ejemplos por √°rea

---

## üí¨ **PREGUNTA PARA EL USUARIO**

¬ø**Procedo a crear los scripts actualizados**?

El algoritmo ahora es:
- ‚úÖ M√°s preciso (√°reas expl√≠citas)
- ‚úÖ M√°s simple (menos c√≥digo)
- ‚úÖ M√°s mantenible (datos en DB)

**Siguiente paso**: Crear los 6 scripts y ejecutarlos para generar `data/job_weights.json`

---

**√öltima actualizaci√≥n**: 2025-10-26
**Estado**: ‚úÖ Algoritmo mejorado con tablas de Areas
